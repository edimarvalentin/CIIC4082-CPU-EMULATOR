#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
       ORG     0FFE8h                  ; Set Vector interrupt for TIMER_A0
       DC16    TIMER_A0_Interrupt      ; Set vector for 'Timer_A0_Interrupt'routine
       

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_Interrupt         ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
       
       
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

                 
        ORG     0x1C00                   ; RAM Starting location


; -----------------------------------------------------------------------------
;                       ARRAYS DEFINITIONS
; -----------------------------------------------------------------------------


; RAM Array Representation
; First 16 Bytes will represent the CPU RAM
; Address       0x1C00, 0x1C01, 0x1C02, 0x1C03, 0x1C04, 0x1C05, 0x1C06, 0x1C07, 0x1C08, 0x1C09,
;               0x1C0A, 0x1C0B, 0x1C0C, 0x1C0D, 0x1C0E, 0x1C0F
; Indices       0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11 ,12 ,13 ,14 ,15
;RAM     db      00101011b, 00010101b,10011010b,01010001b,11001111b,11000011b,01110010b,11101000b,10011111b, 11000001b,11100101b,11000110b,11001101b,11000101b,0xff            
RAM     db      00011100b, 00101101b, 10011000b, 01011111b, 11000010b, 11001110b, 11100100b, 11000101b, 11101010b, 11100101b, 11100110b, 11111011b, 100, 80, 0, 0



ALIGN   1
       
; Letters and Digits Mapping for LCD
; Letter/Digit    A     B     C     D     E     F     G     H     I     J     K     L     M      N    O     P    Q    R      S    T     U       V      W    X     Y   Z     Empty  0      1     2     3     4     5     6    7     8     9
; Indice          0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15   16   17    18    19    20     21     22    23   24   25     26    27    28    29    30    31    32    33    34    35    36
highByte db     0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8F, 0xBD, 0x6F, 0x90, 0x98, 0x00, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7
lowByte  db     0x00, 0x50, 0x00, 0x50, 0x00, 0X00, 0x00, 0x00, 0x50, 0x50, 0x72, 0x00, 0XA0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0X28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00      


; Arrays to build the names for display
; these arrays contain the indices of the letters to be used to display the names

; Project Name
CPURUM_list  db      2, 15, 20, 17, 20, 12
        ALIGN   1
S2TOGO_list  db      18,29,19,14,6,14
        ALIGN   1
       
; Team members names
; The arrays contain the indices that contain the letter to be displayed
john    db      9, 14, 7, 13,26,26
        ALIGN   1
edimar  db      4, 3, 8, 12, 0, 17
        ALIGN   1


GroupNames   dw john,edimar
         ALIGN   1

LCD_offsets     DB      7, 3, 1, 16, 12, 5

s1      DB      00000100B                                                        
s2      DB      00000010B  

                          ; To count how many times button S2
pushCount dw    0         ; is pressed
          ALIGN 1

programState    dw    0         ; This variable informs in which state the program currently is
runningInDebugger db  1         ; 1 if you are going to test it using the debugger. 0 otherwise

          ALIGN 1
intsCounter     dw 0
                Align   1
source          db 0
                Align   1
destination     db 0
                Align   1
iterator        db 0
                Align   1
Instruction     db 0
        Align   1
thing           dw 1
        Align   1
pos1            dw 0x0A29,0x0a25,0x0a23,0x0a2e,0x0a27                          

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


         ; === Port Settings ===

        ; Port 1 Setup
        bis.b   #11111001B, &P1DIR     ; Port 1.1 & Port 1.2 for button input, all other as output

      mov.b   #00000110B, &P1OUT    ; P1.1 Resistor enabled as pullup
        mov.b   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1

        mov.b  #00000110B, &P1IES      ; Int generated on high to low transition

        mov.b   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2



        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        ; === LCD Settings ===

        ; Enable LCD segments: 0-21, 26-43
        MOV     #0xFFFF, &LCDCPCTL0     ; 1111111111111111
        MOV     #0xFC3F, &LCDCPCTL1     ; 1111110000111111
        MOV     #0x0FFF, &LCDCPCTL2     ; 1111111111111111
         
        ; Initialize LCD
        MOV     #0x041e,&LCDCCTL0       ; sets display with hardware specs needed
        MOV     #0x0208, &LCDCVCTL      ; enable voltage for display
        MOV     #0x8000, &LCDCCPCTL     ; enable clock synchronization
        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
        BIS     #1, &LCDCCTL0           ; turn the LCD on


UnlockGPIO:                             ; Disable de GPIO power-on default
        BIC     #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings

        nop

        mov     #CCIE,&TA0CCTL0
        mov     #TASSEL_2+MC_0+ID_3,&TA0CTL
        NOP
        mov     #12500,&TA0CCR0



        bic.b   #00000110b, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
       
       
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV     #0,R10                  ;initialize registers to 0
        MOV     #0,R11
        MOV     #0,R12
        MOV     #0,R13
        MOV     #0,R4

        call    #displayMainTitle  
        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR               ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

SetUpLoop:
        cmp     #2,programState
       
        jlo     SetUpLoop

main:   NOP                             ; main program
        mov     #2,&LCDCMEMCTL
       
MainLoop:
        mov.b   RAM(R4),R5
        ;call    #Decoder
        inc     R4
        cmp     #16,R4
        JNZ     MainLoop
       

        JMP $   

displayContentToLCD:
        push.w  R4                      ; Push the content of the registers into the stack in order to save the content
        push.w  R5                      ; that was in the registers before modifying them. This is done in order to perserve the content.
                                        ; R4 will be used as the register to index the array
                                        ; R5 will be used to contain the current LCD offset
       

        mov.b   #0, R4
       
       
displayContentToLCDLoop:
        mov.b   @R8+,R9                 ; R8 will be used as the register for the array to be traversed
                                        ; Move the current content indicated found at the current index of R8 and move it to R9
                                        ; increase R8 after it in order to move to the next address in memory/location.
 
       
        mov.b   LCD_offsets(R4), R5     ; Store the current offset from the start of the LCD memory to the current iteration's LCD block
       
        mov.b   highByte(R9), 0x0A22(R5); Display the high Byte of the char given by the index in the current position of the array
        mov.b   lowByte(R9),  0x0A22+1(R5); Same concept as before, but in this case we display the low byte of the char

        inc.b   R4                      ; Increase the value at R4 by one in order to move up on the array
        cmp     #6, R4
        jne     displayContentToLCDLoop ; We keep looping while we have missing chars and sections to go through
       
        pop.w   R5                      ; Return R5 to its original state
        pop.w   R4                      ; Return R4 to its original state
        ret
       



displayMainTitle:
        push.w  R8      ; Store the original content of R8 in the stack
        mov.w   #CPURUM_list, R8 ; Store the array containing the indices of the letters of the title into R8 to display them
        call    #displayContentToLCD ; Call subroutine that displays the content found in the array
        pop.w   R8      ; Restore the R8 to its previous state
        ret
 


displayGroupMembersNamesSetUp:
        push.w  R8                                                              ; Save original content of R8
        mov.w   GroupNames(R7), R8                                              ;Use R8 has the register where the address
                                                                                ;for the array will be found in the loop
        call    #displayContentToLCD                                          
        pop.w   R8                                                              ; restore R8 to its original value
        ret
       
displayGroupMembersNames:
        push.w  R7                                                              ; Save original content of R7
        mov.w   pushCount, R7                                                   ; push the current count of S2 into R7
        call    #displayGroupMembersNamesSetUp                                  ; Call the display function for this array      
        pop.w   R7                                                              ; Restore R7 to its original value
        incd    pushCount                                                       ; increase by 2 the counter to get the next word
        cmp     #4, pushCount
        jeq     resetCount                                                      ; if all names have been displayed, reset the counter
        ret                                                                     ; to start the circular list

resetCount:
        mov.w   #0, pushCount                                                   ; Reset the pushCount variable to start
        ret                                                                     ; the indexing at the beginning
       
displayS2ToGo:
        push.w  R8
        mov.w   #S2TOGO_list,R8                                                      ; Move the address of the first element of the array
        call    #displayContentToLCD                                            ; Display the chars into the LCD
        pop.w   R8
        inc.w   programState                                                    ; increase the programState to determine that
        ret                                                                     ; the program is in a new state


TIMER_A0_Interrupt:
        mov     #4,R8
loopLCD:
        mov     pos1(R8),R9
        cmp     #0x0a25,R9
        jz      loopLCDDec
        cmp.b   #11100111b,0(R9)
        JZ      SubToEight
        cmp.b   #11111111b,0(R9)
        JZ      SubToSeven
        cmp.b   #11100000b,0(R9)
        JZ      SubToSix
        cmp.b   #10111111b,0(R9)
        JZ      SubToFive
        cmp.b   #10110111b,0(R9)
        JZ      SubToFour
        cmp.b   #01100111b,0(R9)
        JZ      SubToThree
        cmp.b   #11110011b,0(R9)
        JZ      SubToTwo
        cmp.b   #11011011b,0(R9)
        JZ      SubToOne
        cmp.b   #01010000b,1(R9)
        JZ      SubToZero
        JMP     SubToNine
loopLCDDec:
        cmp.b   #11100111b,0(R9)
        JZ      SubToEight
        cmp.b   #11111111b,0(R9)
        JZ      SubToSeven
        cmp.b   #11100000b,0(R9)
        JZ      SubToSix
        cmp.b   #10111111b,0(R9)
        JZ      SubToFive
        cmp.b   #10110111b,0(R9)
        JZ      SubToFour
        cmp.b   #01100111b,0(R9)
        JZ      SubToThree
        cmp.b   #11110011b,0(R9)
        JZ      SubToTwo
        cmp.b   #11011011b,0(R9)
        JZ      SubToOneDec
        cmp.b   #01010001b,1(R9)
        JZ      SubToZeroDec
        JMP     SubToNine
makeTen:
        mov.b   #11111100b,&0x0a29
        nop
        mov.b   #11111100b,&0x0a25
        nop
        mov.b   #11111100b,&0x0a23
        nop
        bic     #0000000000010000b,&TA0CTL
        JMP     Interfinish
SubToEight:
        mov.b   #11111111b,0(R9)
        JMP     Interfinish
SubToSeven:
        mov.b   #11100000b,0(R9)
        JMP     Interfinish
SubToSix:
        mov.b   #10111111b,0(R9)
        JMP     Interfinish
SubToFive:
        mov.b   #10110111b,0(R9)
        JMP     Interfinish
SubToFour:
        mov.b   #01100111b,0(R9)
        JMP     Interfinish
SubToThree:
        mov.b   #11110011b,0(R9)
        JMP     Interfinish
SubToTwo:
        mov.b   #11011011b,0(R9)
        JMP     Interfinish
SubToOne:
        mov.b   #0x00,0(R9)
        mov.b   #01010000b,1(R9)
        JMP     Interfinish
SubToOneDec:
        mov.b   #0x00,0(R9)
        mov.b   #01010001b,1(R9)
        JMP     Interfinish
SubToZero:
        mov.b   #11111100b,0(R9)
        mov.b   #0x00,1(R9)
        JMP     Interfinish
SubToZeroDec:
        mov.b   #11111100b,0(R9)
        mov.b   #0x01,1(R9)
        JMP     Interfinish
SubToNine:
        mov.b   #11100111b,0(R9)
        sub     #2,R8
        cmp.b   #-2,R8
        JNZ     loopLCD
        JMP     makeTen
       
Interfinish:
        RETI


PORT1_Interrupt:
        nop
        bic.b   #00000110b, &P1IFG    ;Reset interrupt flag
        nop
       
        call    #delay

       
        mov.b   &P1IN, R9                 ; Move the current value of P1 into a register to better analyze
       
        and.b   #00000110B, R9            ; Apply bit mask to just compare with the bits we care about

        cmp.b   s1, R9                    ; Check if S1 was pressed
        jeq     S1_INPUT
       
        cmp.b   s2, R9                    ; Check if S2 was pressed
        jeq     S2_INPUT
       
        jmp     PORT1_Interrupt_END
       
       
       
S1_INPUT:
        cmp.w   #0, programState                                                 ; Check in which part of the program we currently are in
        jeq     S1_ACTION_TOGO                                                   ; Only display 'S2TOGO' in the initial state (CPURUM)
        jmp     PORT1_Interrupt_END                                              ; Nothing happens if we are not in the correct state
       
       
S2_INPUT:                                                                    
        cmp.w   #0, programState                                                 ; If in state 0 and S2 is pressed, display the group names
        jeq     S2_ACTION_NAMES
       
        cmp.w   #1, programState                                                 ; If in state 1 ('S2TOGO') and S2 is pressed,
        jeq     S2_START_PROGRAM                                                 ; initiate program execution
        jmp     PORT1_Interrupt_END                                              ; Everything else, end the interrupt
       
S1_ACTION_TOGO:
        call    #displayS2ToGo                                                   ; Display the text 'S2TOGO' in the LCD
        jmp     PORT1_Interrupt_END                                              ; End current interrupt after this      
       
S2_ACTION_NAMES:
        call    #displayGroupMembersNames                                        ; Display the groups members names after each
        jmp     PORT1_Interrupt_END                                              ; Press of S2
       
S2_START_PROGRAM:
        inc.w   programState                                                     ; Initiate the program after 'S2TOGO' text
        jmp     PORT1_Interrupt_END
       
       
PORT1_Interrupt_END:
        reti
               
 

delay:
        push.w  R7
        call    #startDelay
        pop.w   R7
        ret
       
startDelay:
        mov     #0x5fff, R7

delayDecrease:
        dec     R7
        jnz     delayDecrease
        ret
;------------------------------------------------------------------------------      
 programEnd:      
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        NOP                             ; add this instruction so that we dont get an error
        END
