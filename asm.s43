#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.

        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        
        
        ORG     0x1C00                  ; moving to set some variables

                ;Load 5
                ;to R0
RAM     db      00111101b, 01111001b, 10010100b, 11000001b, 11000101b, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5

; Letters and Digits Mapping for LCD
; Letter/Digit    A     B     C     D     E     F     G     H     I     J     K     L     M      N    O     P    Q    R      S    T     U       V      W    X     Y   Z     Empty  0      1     2     3     4     5     6    7     8     9
; Indice          0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15   16   17    18    19    20     21     22    23   24   25     26    27    28    29    30    31    32    33    34    35    36
highByte db     0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8F, 0xBD, 0x6F, 0x90, 0x98, 0x00, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7
         align 1
lowByte  db     0x00, 0x50, 0x00, 0x50, 0x00, 0X00, 0x00, 0x00, 0x50, 0x50, 0x72, 0x00, 0XA0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0X28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00    
         align 1

;LCD Alphanumerics 1 to 6
alphanumeric db 9, 5, 3, 18, 14, 7
             align 1

;CPURUM array
CPURUM  db      2, 15, 20, 17, 20, 12
        align   1
        
;ST2GO array
S2TOGO   db     18, 29, 19, 14, 6, 14
        align   1
        
;Names
EDIMAR db       4, 3, 8, 12, 0, 17
       align    1
       
JOHN   db       9, 14, 7, 13, 26, 26
       align    1
       
NORELY  db      13, 14, 17, 4, 11, 24
        align   1
        
BRYANT  db      1, 17, 24, 0, 13, 19
        align   1
      
;To know and compare what state is the program in       
STATE    dw    0

S2COUNT  dw    0
        
        ORG     0FFFEh                  ; back to normal
        
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

SetupP1:
        BIS.B   #11111001B, &P1DIR      ; Port 1.1 & Port 1.2 for button input, all other as output
        MOV.B   #00000110B, &P1OUT      ; P1.1 Resistor enabled as pullup
        MOV.B   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1
        MOV.B   #00000110B, &P1IES      ; Int generated on high to low transition
        MOV.B   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2
        
        ;Initialize LCD segments 0 - 21; 26 - 43
	MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2
        
UnlockGPIO:
        BIC.W   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings
        NOP

        ;Intialize LCD_C
        MOV.W   #0x041e,&LCDCCTL0
        
        ;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL
        
        MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

        MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        BIS.W   #1,&LCDCCTL0         ;Turn on LCD

displayCPURUM:
        PUSH.W R4                       ;Save the content of R4 to the stack to back it up
        MOV.W #CPURUM, R4               ;Move the address of CPURUM to R4 so we can iterate it to the LCD
        CALL #R4toLCD                   ;Display the content of R4 to the LCD
        POP.W R4                        ;Return R4 to the original state 

enablePort1_ISR:
        bic.b   #00000010b, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
        NOP                             ;NOP before setting GIE required by
                                        ;the architecture
        BIS.W   #GIE,SR 	        ;Interrupts enabled (same as eint)
                                        ;so that the micro reacts to 
                                        ;interrupts
        NOP                             ;Wait after setting interrupt bit

StartLoop:
        CMP #2, STATE
        JLO StartLoop
        
SETUP:
        MOV.B #0, R4                    ; R4 AS PC
        MOV.B #0, R5                    ; R5 AS IR
        MOV.B #0, R6                    ; R6 AS MAR
        MOV.B #0, R7                    ; R7 AS MBR
        MOV.B #0, R8                    ; R8 AS RA

        
        
LOOP:

        MOV.B RAM(R4), R5               ; Fetch 
        INC.B R4                        ; Increment PC
        CALL #DECODER                   ; Decode and Execute

        CMP.B #16, R4                   ;Check if out bounds
        JEQ SETUP                       ;Restart the program if so
        JMP LOOP                        ;Resume program if not
     
        JMP $
        

;Objetivo: Decodifar una instruccion en IR (R5) y ejecutarla

;Precondiciones: (IR) R5 tiene que tener una instruccion valida

;Postcondiciones: Load, Store, Add, Neg, Shr, In, Out, JR30

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023               
DECODER:
        ;Is it a load?
        PUSH.B R5                       ;Back up instruction before we mask it.
        AND.B #11000000b,R5
        CMP.B #0,R5
        POP.B R5                        ;Lets get it back
        JEQ DECODER_LOAD_SUB
        
        ;Is it a store?
        PUSH.B R5                       
        AND.B #10000000b,R5
        CMP.B #0,R5
        POP.B R5                        
        JEQ DECODER_STORE_SUB
        
        ;Is it an add?
        PUSH.B R5
        AND.B #01000000b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_ADD_SUB
        
        ;Is it a negation?
        PUSH.B R5
        AND.B #00111100b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_NEG_SUB
        
        ;Is it a right shift?
        PUSH.B R5
        AND.B #00111000b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_SHR_SUB
        
        ;Is it a Jump if R3?
        PUSH.B R5
        AND.B #00000000b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_JR30_SUB
        
DECODER_LOAD_SUB:
        CALL #LOAD_SUB
        RET
        
DECODER_STORE_SUB:
        CALL #STORE_SUB
        RET

DECODER_ADD_SUB:
        CALL #ADD_SUB
        RET
        
DECODER_NEG_SUB:
        CALL #NEG_SUB
        RET
        
DECODER_SHR_SUB:
        CALL #SHR_SUB
        RET
        
DECODER_JR30_SUB:
        CALL #JR30_SUB
        RET


;Objetivo: Cargar un contenido de la memoria RAM al registro correspondiente

;Precondiciones: (IR) R5 tiene que especificar el registro y la direccion en memoria

;Postcondiciones: Un registro tendra el contenido que se copio de la memoria

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023            
LOAD_SUB:
        PUSH.B R5                       ;Back up instruction before we mask it.
        AND.B #00111100b, R5            ;Time to do some binary magic to get our address
        RRA.B R5
        RRA.B R5                        ;After this, we should be pointing to the right location
        MOV.B RAM(R5), R7 
        POP.B R5
        
        PUSH.B R5
        AND.B #00000011b, R5            ;We should point now to the correct register
        
        CMP.B #0, R5                    ;Register 0
        JEQ LOAD_SUB_R0

        CMP.B #1, R5                    ;Register 1
        JEQ LOAD_SUB_R1

        CMP.B #2, R5                    ;Register 2
        JEQ LOAD_SUB_R2

        CMP.B #3, R5                    ;Register 3
        JEQ LOAD_SUB_R3
        
LOAD_SUB_R0:
        MOV.B R7, R10                   ; MBR TO R0
        JMP LOAD_SUB_END
        
LOAD_SUB_R1:
        MOV.B R7, R11                   ; MBR TO R1
        JMP LOAD_SUB_END
        
LOAD_SUB_R2:
        MOV.B R7, R12                   ; MBR TO R2
        JMP LOAD_SUB_END
        
LOAD_SUB_R3:
        MOV.B R7, R13                   ; MBR TO R3

LOAD_SUB_END:
        POP.B R5                        ;If we don't pop, ret wont work. R5 is no longer important now
        RET
        
        
;Objetivo: Guardar un contenido de un registro al RAM segun la direccion en la instruccion 

;Precondiciones: (IR) R5 tiene que especificar el registro y la direccion en memoria

;Postcondiciones: El RAM tendra el contenido del registro especifico

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023    
STORE_SUB:
        PUSH.B R5                       ;Back up instruction before we mask it.
        AND.B #00000011b, R5            ;Time to do some binary magic to get our register                   
                                        ;After this, we should be pointing to the right location
        
        CMP.B #0, R5                    ;Register 0
        JEQ STORE_SUB_R0

        CMP.B #1, R5                    ;Register 1
        JEQ STORE_SUB_R1

        CMP.B #2, R5                    ;Register 2
        JEQ STORE_SUB_R2

        CMP.B #3, R5                    ;Register 3
        JEQ STORE_SUB_R3
        
STORE_SUB_R0:
        MOV.B R10, R7                   ;R0 TO MBR
        JMP STORE_SUB_RAM

STORE_SUB_R1:
        MOV.B R11, R7                   ;R1 TO MBR
        JMP STORE_SUB_RAM

STORE_SUB_R2:
        MOV.B R12, R7                   ;R2 TO MBR
        JMP STORE_SUB_RAM
        
STORE_SUB_R3:
        MOV.B R13, R7                   ;R3 TO MBR
        JMP STORE_SUB_RAM

STORE_SUB_RAM:
        POP.B R5  
        AND.B #00111100b, R5
        RRA.B R5
        RRA.B R5
        MOV.B R7, RAM(R5)
        RET
        
;Objetivo: Sumar el contenido de dos registros RA = RA + RB

;Precondiciones: (IR) R5 tiene que especificar los regitros a sumsarse

;Postcondiciones: El registro espcicado en los bits mas signifativos guardara la suma

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023    
ADD_SUB:
        PUSH.B R5
        AND.B #00001100b, R5
        RRA.B R5
        RRA.B R5
        
        CMP.B #0, R5
        JEQ ADD_SUB_R0_RA
        
        CMP.B #1, R5
        JEQ ADD_SUB_R1_RA
        
        CMP.B #2, R5
        JEQ ADD_SUB_R2_RA
        
        CMP.B #3, R5
        JEQ ADD_SUB_R3_RA
        
ADD_SUB_R0_RA:
        MOV.B R10, R8
        JMP ADD_SUB_RA

ADD_SUB_R1_RA:
        MOV.B R11, R8
        JMP ADD_SUB_RA
        
ADD_SUB_R2_RA:
        MOV.B R12, R8
        JMP ADD_SUB_RA

ADD_SUB_R3_RA:
        MOV.B R13, R8
        
ADD_SUB_RA:
        POP.B R5
        AND.B #00110000b, R5
        RRA.B R5
        RRA.B R5
        RRA.B R5
        RRA.B R5
        
        CMP.B #0, R5
        JEQ ADD_SUB_RA_R0
        
        CMP.B #1, R5
        JEQ ADD_SUB_RA_R1
 
        CMP.B #2, R5
        JEQ ADD_SUB_RA_R2
        
        CMP.B #3, R5
        JEQ ADD_SUB_RA_R3

ADD_SUB_RA_R0:
        ADD.B R8, R10   
        JMP ADD_SUB_END
        
ADD_SUB_RA_R1:
        ADD.B R8, R11
        JMP ADD_SUB_END

ADD_SUB_RA_R2:
        ADD.B R8, R12
        JMP ADD_SUB_END
        
ADD_SUB_RA_R3:
        ADD.B R8, R13
        JMP ADD_SUB_END
        
ADD_SUB_END:
        RET
        
;Objetivo: Guardar el 2'scomplement de un registro en el mismo

;Precondiciones: (IR) R5 tine que especificar el registro

;Postcondiciones: El registro especificado tendra el 2's complement de su contenido anterior

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023           
NEG_SUB:
        AND.B #00000011b, R5
        
        CMP.B #0, R5
        JEQ NEG_SUB_R0
        
        CMP.B #1, R5
        JEQ NEG_SUB_R1
        
        CMP.B #2, R5
        JEQ NEG_SUB_R2
        
        CMP.B #3, R5
        JEQ NEG_SUB_R3
        
NEG_SUB_R0:
        INV.B R10
        ADD.B #1, R10
        JMP NEG_SUB_END
        
NEG_SUB_R1:
        INV.B R11
        ADD.B #1, R11
        JMP NEG_SUB_END
    
NEG_SUB_R2:
        INV.B R12
        ADD.B #1, R12
        JMP NEG_SUB_END
        
NEG_SUB_R3:
        INV.B R13
        ADD.B #1, R13
        JMP NEG_SUB_END
        
NEG_SUB_END:
        RET
        

;Objetivo: Hacer un "shift" de bits hacia la derecha en un registro

;Precondiciones: (IR) R5 tine que especificar el registro

;Postcondiciones: El registro especificado tendra la mitad del contenido anterior

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023            
SHR_SUB:
        AND.B #00000011b, R5
        
        CMP.B #0, R5
        JEQ SHR_SUB_R0
        
        CMP.B #1, R5
        JEQ SHR_SUB_R1
        
        CMP.B #2, R5
        JEQ SHR_SUB_R2
        
        CMP.B #3, R5
        JEQ SHR_SUB_R3
        
SHR_SUB_R0:
        RRA.B R10
        JMP SHR_SUB_END
        
SHR_SUB_R1:
        RRA.B R11
        JMP SHR_SUB_END
    
SHR_SUB_R2:
        RRA.B R12
        JMP SHR_SUB_END
        
SHR_SUB_R3:
        RRA.B R13
        JMP SHR_SUB_END
      
SHR_SUB_END:
        RET

;Objetivo: Cambiar el contenido del PC si R3 tiene un 0

;Precondiciones: IR (R5) tiene que especificar el valor ira en el PC (R4).
;                R3 (R13) tiene que tener contenido un 0

;Postcondiciones: PC (R4) tendra el contenido que se le indico en el IR (R5).

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023    
JR30_SUB:
        CMP.B #0,R12
        JNE JR30_SUB_END
        AND.B #00001111b, R5
        MOV.B R5, R4       
JR30_SUB_END:
        RET
        
        
;Objetivo: Mostrar los primeros 6 caracteres alfanumericos a partir de un array

;Precondiciones: Poner una direccion en R4

;Postcondiciones: El LCD mostara el contenido correspondiente hasta que se cambie 

;Autor: Edimar Valentin Kery

;Fecha: 19/abr/2023              
R4toLCD:
        PUSH.W R5                       ;We're gonna need these three registers to do our iteration business. We're backing up their contents
        PUSH.W R6                       ;to the stack.
        PUSH.W R7                       

        MOV.B #0, R5                    ;We're gonna use R5 to iterate the alphanumerics on the LCD
R4toLCDLoop:
        MOV.B  @R4+, R6                 ;This is is gonna work as our index for the content on R4. We move to it to R6 and increment it by one

        MOV.B alphanumeric(R5), R7      ;We copy the position of the alphanumeric to the LCD


        MOV.B highByte(R6), 0x0A20(R7)  ;The corresponding high byte with the corresponding alphanumeric
      
        MOV.B lowByte(R6), 0x0A20+1(R7) ;The corresponding low byte with the corresponding alphanumeric
      
        INC.B R5                        ;Increment R5 to go to the next alphanumeric
      
        CMP #6, R5                      ;If R5 reached 6, that means there's no more space on the LCD
      
        JNE R4toLCDLoop                 ;If there still space, repeat the subroutine with the new values

        POP.W R7                        ;We return the used registers to the their original state. 
        POP.W R6
        POP.W R5
        
        RET                             ;We return to wherever we were called 



;Objetivo: Interrupt Service Routine que maneja las acciones a tomar de s1 o s2

;Precondiciones: Las interrupciones en P1.1 & P1.2 y el MSP430 en general tienen que estar habilitadas.
;                El programa tiene que estar en el estado de 'CPURUM', 'S2TOGO' o mostrando los nombres de los integrantes.

;Postcondiciones: Mostrar el nombre del siguiente integrante, mostrar 'S2TOGO' o empezar el programa.

;Autor: Edimar Valentin Kery

;Fecha: 19/abr/2023  
PORT1_ISR:
        
        PUSH.W R4
        
        NOP
        BIC.B   #6, &P1IFG        
        NOP
        
        CALL    #DELAY
        
        MOV.B   &P1IN, R4               
        
        AND.B   #00000110B, R4 
        
        cmp.b   #4, R4           
        jeq     S1_PRESSED_ISR  
       
        cmp.b   #2, R4                   
        jeq     S2_PRESSED_ISR
        
        JMP END_PORT1_ISR
        
        
S1_PRESSED_ISR:
        PUSH.W R4
        MOV.W #S2TOGO, R4
        CALL #R4toLCD
        POP.W R4
        INC.W STATE
        JMP END_PORT1_ISR
   
S2_PRESSED_ISR:
        CMP.W #0, STATE
        JEQ SHOW_NAME_ISR
        
        CMP.W #1, STATE
        JEQ START_PROGRAM_ISR
        
        JMP END_PORT1_ISR
        
START_PROGRAM_ISR:
        INC.W STATE
        JMP END_PORT1_ISR
          
SHOW_NAME_ISR:
        CMP.W #0, S2COUNT
        JEQ DISPLAY_EDIMAR_ISR
        
        CMP.W #1, S2COUNT
        JEQ DISPLAY_JOHN_ISR
        
        CMP.W #2, S2COUNT
        JEQ DISPLAY_NORELY_ISR
        
        CMP.W #3, S2COUNT
        JEQ DISPLAY_BRYANT_ISR
        
        JMP END_PORT1_ISR
        
DISPLAY_EDIMAR_ISR:
        PUSH.W R4
        MOV.W #EDIMAR, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_JOHN_ISR:
        PUSH.W R4
        MOV.W #JOHN, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_NORELY_ISR:
        PUSH.W R4
        MOV.W #NORELY, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_BRYANT_ISR:
        PUSH.W R4
        MOV.W #BRYANT, R4
        CALL #R4toLCD
        POP.W R4
        MOV.W #0, S2COUNT
        JMP END_PORT1_ISR
        
END_PORT1_ISR:
        POP.W R4
        reti
        
   
;Objetivo: Crear un delay para no actuar en el sonido de los botons s1 y s2

;Precondiciones: Ninguna

;Postcondiciones: La subrutina no genera cambios 

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023

DELAY:
        PUSH.W R4
        MOV #1000, R4
NEXT:   
        DEC.W R4
        JNZ NEXT
        POP.W R4
        RET
                                              
END      
   


        
 
    