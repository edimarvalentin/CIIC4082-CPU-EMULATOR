#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.

        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        
        
        ORG     0x1C00                  ; moving to set some variables

               
;11001101b in 01
;11100110b out R1 to 02
;Load 00101111b ;R2 TO 1111
;Store 01111110b  ;R3
;Add 10100000b  ;ADD R2 + R0
;Neg 11000010b  ;NEG 10
;Shr 11000111b  ;shift R3
;JR30 11111011b  ;jr 30 1011

RAM     db      11001101b, 11100110b, 00101111b, 01111110b, 10100000b, 11000010b, 11000111b,11111011b, 0, 0, 0, 0, 0, 0, 0, 5

; Letters and Digits Mapping for LCD
; Letter/Digit    A     B     C     D     E     F     G     H     I     J     K     L     M      N    O     P    Q    R      S    T     U       V      W    X     Y   Z     Empty  0      1     2     3     4     5     6    7     8     9
; Indice          0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15   16   17    18    19    20     21     22    23   24   25     26    27    28    29    30    31    32    33    34    35    36
highByte db     0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8F, 0xBD, 0x6F, 0x90, 0x98, 0x00, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7
         align 1
lowByte  db     0x00, 0x50, 0x00, 0x50, 0x00, 0X00, 0x00, 0x00, 0x50, 0x50, 0x72, 0x00, 0XA0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0X28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00    
         align 1

;LCD Alphanumerics 1 to 6
alphanumeric db 9, 5, 3, 18, 14, 7
             align 1

;CPURUM array
CPURUM  db      2, 15, 20, 17, 20, 12
        align   1
        
;ST2GO array
S2TOGO   db     18, 29, 19, 14, 6, 14
        align   1
        
;Names
EDIMAR db       4, 3, 8, 12, 0, 17
       align    1
       
JOHN   db       9, 14, 7, 13, 26, 26
       align    1
       
NORELY  db      13, 14, 17, 4, 11, 24
        align   1
        
BRYANT  db      1, 17, 24, 0, 13, 19
        align   1
TEN     db      28,27
        align   1
ELLEVEN  db     28,28
        align   1
TWELVE  db      28,29
        align   1
THRIDTEEN  db  28,30
        align   1
FOURTEEN  db    28,31
        align   1
FITHTEEN  db    28,32
        align   1
pos1    dw 0x0A29,0x0a25,0x0a23,0x0a2e,0x0a27
        align   1
runindebugger db 0 ;1 to test in debugger 0 otherwise
        
        
      
;To know and compare what state is the program in       
STATE    dw    0

S2COUNT  dw    0
        
        ORG     0FFFEh                  ; back to normal
        
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

SetupP1:
        BIS.B   #11111001B, &P1DIR      ; Port 1.1 & Port 1.2 for button input, all other as output
        MOV.B   #00000110B, &P1OUT      ; P1.1 Resistor enabled as pullup
        MOV.B   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1
        MOV.B   #00000110B, &P1IES      ; Int generated on high to low transition
        MOV.B   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2
        
        ;Initialize LCD segments 0 - 21; 26 - 43
	MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2
        
UnlockGPIO:
        BIC.W   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings
        NOP

        ;Intialize LCD_C
        MOV.W   #0x041e,&LCDCCTL0
        
        ;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL
        
        MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

        MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        BIS.W   #1,&LCDCCTL0         ;Turn on LCD

displayCPURUM:
        PUSH.W R4                       ;Save the content of R4 to the stack to back it up
        MOV.W #CPURUM, R4               ;Move the address of CPURUM to R4 so we can iterate it to the LCD
        CALL #R4toLCD                   ;Display the content of R4 to the LCD
        POP.W R4                        ;Return R4 to the original state 

enablePort1_ISR:
        bic.b   #00000010b, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
        NOP                             ;NOP before setting GIE required by
                                        ;the architecture
        BIS.W   #GIE,SR 	        ;Interrupts enabled (same as eint)
                                        ;so that the micro reacts to 
                                        ;interrupts
        NOP                             ;Wait after setting interrupt bit

StartLoop:
        CMP #2, STATE
        JLO StartLoop
        
SETUP:  

        MOV.W   #2,&LCDCMEMCTL          ;Clear LCD memory

        MOV.B #0,R10                    ;Always 0
        MOV.B #128,R11
        MOV.B #0, R4                    ; R4 AS PC
        MOV.B #0, R5                    ; R5 AS IR
        MOV.B #0, R6                    ; R6 AS MAR
        MOV.B #0, R7                    ; R7 AS MBR
        MOV.B #0, R8                    ; R8 AS RA

        
        
LOOP:

        MOV.B RAM(R4), R5               ; Fetch 
        INC.B R4                        ; Increment PC
        CALL #DECODER                   ; Decode and Execute

        CMP.B #16, R4                   ;Check if out bounds
        JEQ SETUP                       ;Restart the program if so
        JMP LOOP                        ;Resume program if not
     
        JMP $
        

;Objetivo: Decodifar una instruccion en IR (R5) y ejecutarla

;Precondiciones: (IR) R5 tiene que tener una instruccion valida

;Postcondiciones: Load, Store, Add, Neg, Shr, In, Out, JR30

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023               
DECODER:
        ;Is it a load?
        PUSH.B R5                       ;Back up instruction before we mask it.
        AND.B #11000000b,R5
        CMP.B #0,R5
        POP.B R5                        ;Lets get it back
        JEQ DECODER_LOAD_SUB
        
        ;Is it a store?
        PUSH.B R5                       
        AND.B #10000000b,R5
        CMP.B #0,R5
        POP.B R5                        
        JEQ DECODER_STORE_SUB
        
        ;Is it an add?
        PUSH.B R5
        AND.B #01000000b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_ADD_SUB
        
        ;Is it a negation?
        PUSH.B R5
        AND.B #00111100b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_NEG_SUB
        
        ;Is it a right shift?
        PUSH.B R5
        AND.B #00111000b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_SHR_SUB
        
        ;Is it In?
        PUSH.B R5
        AND.B #00110000b, R5
        CMP.B #0, R5 
        POP.B R5
        JEQ DECODER_IN_SUB
        
        ;Is it OUT ?
        PUSH.B R5
        AND.B #11110000B,R5
        CMP.B #11100000B,R5
        POP.B R5
        JEQ DEOCODER_OUT_SUB
        
        ;Is it a Jump if R3?
        PUSH.B R5
        AND.B #00000000b, R5
        CMP.B #0, R5
        POP.B R5
        JEQ DECODER_JR30_SUB
        
DECODER_LOAD_SUB:
        CALL #LOAD_SUB
        RET
        
DECODER_STORE_SUB:
        CALL #STORE_SUB
        RET

DECODER_ADD_SUB:
        CALL #ADD_SUB
        RET
        
DECODER_NEG_SUB:
        CALL #NEG_SUB
        RET
        
DECODER_SHR_SUB:
        CALL #SHR_SUB
        RET
        
DECODER_IN_SUB:
        CALL #IN_SUB
        RET
        
DEOCODER_OUT_SUB:
        CALL #OUT_SUB
        RET
        
DECODER_JR30_SUB:
        CALL #JR30_SUB
        RET


;Objetivo: Cargar un contenido de la memoria RAM al registro correspondiente

;Precondiciones: (IR) R5 tiene que especificar el registro y la direccion en memoria

;Postcondiciones: Un registro tendra el contenido que se copio de la memoria

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023            
LOAD_SUB:
        PUSH.B R5                       ;Back up instruction before we mask it.
        AND.B #00111100b, R5            ;Time to do some binary magic to get our address
        RRA.B R5
        RRA.B R5                        ;After this, we should be pointing to the right location
        MOV.B RAM(R5), R7 
        POP.B R5
        
        PUSH.B R5
        AND.B #00000011b, R5            ;We should point now to the correct register
       
        CMP.B #1, R5                    ;Register 1
        JEQ LOAD_SUB_R1

        CMP.B #2, R5                    ;Register 2
        JEQ LOAD_SUB_R2

        CMP.B #3, R5                    ;Register 3
        JEQ LOAD_SUB_R3
        

        
LOAD_SUB_R1:
        MOV.B R7, R11                   ; MBR TO R1
        JMP LOAD_SUB_END
        
LOAD_SUB_R2:
        MOV.B R7, R12                   ; MBR TO R2
        JMP LOAD_SUB_END
        
LOAD_SUB_R3:
        MOV.B R7, R13                   ; MBR TO R3

LOAD_SUB_END:
        POP.B R5                        ;If we don't pop, ret wont work. R5 is no longer important now
        RET
        
        
;Objetivo: Guardar un contenido de un registro al RAM segun la direccion en la instruccion 

;Precondiciones: (IR) R5 tiene que especificar el registro y la direccion en memoria

;Postcondiciones: El RAM tendra el contenido del registro especifico

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023    
STORE_SUB:
      PUSH.B R5                       ;Back up instruction before we mask it.
        AND.B #00000011b, R5            ;Time to do some binary magic to get our register                   
                                        ;After this, we should be pointing to the right location
        
        CMP.B #0, R5                    ;Register 0
        JEQ STORE_SUB_R0

        CMP.B #1, R5                    ;Register 1
        JEQ STORE_SUB_R1

        CMP.B #2, R5                    ;Register 2
        JEQ STORE_SUB_R2

        CMP.B #3, R5                    ;Register 3
        JEQ STORE_SUB_R3
        
STORE_SUB_R0:
        MOV.B R10, R7                   ;R0 TO MBR
        JMP STORE_SUB_RAM

STORE_SUB_R1:
        MOV.B R11, R7                   ;R1 TO MBR
        JMP STORE_SUB_RAM

STORE_SUB_R2:
        MOV.B R12, R7                   ;R2 TO MBR
        JMP STORE_SUB_RAM
        
STORE_SUB_R3:
        MOV.B R13, R7                   ;R3 TO MBR
        JMP STORE_SUB_RAM

STORE_SUB_RAM:
        POP.B R5  
        AND.B #00111100b, R5
        RRA.B R5
        RRA.B R5
        MOV.B R7, RAM(R5)
        RET
        
;Objetivo: Sumar el contenido de dos registros RA = RA + RB

;Precondiciones: (IR) R5 tiene que especificar los regitros a sumsarse

;Postcondiciones: El registro espcicado en los bits mas signifativos guardara la suma

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023    
ADD_SUB:
        PUSH.B R5
        AND.B #00001100b, R5
        RRA.B R5
        RRA.B R5
        
        CMP.B #0, R5
        JEQ ADD_SUB_R0_RA
        
        CMP.B #1, R5
        JEQ ADD_SUB_R1_RA
        
        CMP.B #2, R5
        JEQ ADD_SUB_R2_RA
        
        CMP.B #3, R5
        JEQ ADD_SUB_R3_RA
        
ADD_SUB_R0_RA:
        MOV.B R10, R8
        JMP ADD_SUB_RA

ADD_SUB_R1_RA:
        MOV.B R11, R8
        JMP ADD_SUB_RA
        
ADD_SUB_R2_RA:
        MOV.B R12, R8
        JMP ADD_SUB_RA

ADD_SUB_R3_RA:
        MOV.B R13, R8
        
ADD_SUB_RA:
        POP.B R5
        AND.B #00110000b, R5
        RRA.B R5
        RRA.B R5
        RRA.B R5
        RRA.B R5
        
        CMP.B #0, R5
        JEQ ADD_SUB_RA_R0
        
        CMP.B #1, R5
        JEQ ADD_SUB_RA_R1
 
        CMP.B #2, R5
        JEQ ADD_SUB_RA_R2
        
        CMP.B #3, R5
        JEQ ADD_SUB_RA_R3

ADD_SUB_RA_R0:
        ADD.B R8, R10   
        JMP ADD_SUB_END
        
ADD_SUB_RA_R1:
        ADD.B R8, R11
        JMP ADD_SUB_END

ADD_SUB_RA_R2:
        ADD.B R8, R12
        JMP ADD_SUB_END
        
ADD_SUB_RA_R3:
        ADD.B R8, R13
        JMP ADD_SUB_END
        
ADD_SUB_END:
        RET
        
;Objetivo: Guardar el 2'scomplement de un registro en el mismo

;Precondiciones: (IR) R5 tine que especificar el registro

;Postcondiciones: El registro especificado tendra el 2's complement de su contenido anterior

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023           
NEG_SUB:
        AND.B #00000011b, R5
        
        CMP.B #0, R5
        JEQ NEG_SUB_R0
        
        CMP.B #1, R5
        JEQ NEG_SUB_R1
        
        CMP.B #2, R5
        JEQ NEG_SUB_R2
        
        CMP.B #3, R5
        JEQ NEG_SUB_R3
        
NEG_SUB_R0:
        INV.B R10
        ADD.B #1, R10
        JMP NEG_SUB_END
        
NEG_SUB_R1:
        INV.B R11
        ADD.B #1, R11
        JMP NEG_SUB_END
    
NEG_SUB_R2:
        INV.B R12
        ADD.B #1, R12
        JMP NEG_SUB_END
        
NEG_SUB_R3:
        INV.B R13
        ADD.B #1, R13
        JMP NEG_SUB_END
        
NEG_SUB_END:
        RET
        

;Objetivo: Hacer un "shift" de bits hacia la derecha en un registro

;Precondiciones: (IR) R5 tine que especificar el registro

;Postcondiciones: El registro especificado tendra la mitad del contenido anterior

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023            
SHR_SUB:
        AND.B #00000011b, R5
        
        CMP.B #0, R5
        JEQ SHR_SUB_R0
        
        CMP.B #1, R5
        JEQ SHR_SUB_R1
        
        CMP.B #2, R5
        JEQ SHR_SUB_R2
        
        CMP.B #3, R5
        JEQ SHR_SUB_R3
        
SHR_SUB_R0:
        RRA.B R10
        JMP SHR_SUB_END
        
SHR_SUB_R1:
        RRA.B R11
        JMP SHR_SUB_END
    
SHR_SUB_R2:
        RRA.B R12
        JMP SHR_SUB_END
        
SHR_SUB_R3:
        RRA.B R13
        JMP SHR_SUB_END
      
SHR_SUB_END:
        RET
        
;Objetivo: Guardar los dos bits correspondientes a P1.1 & P1.2 en el registro designado

;Precondiciones: (IR) R5 tine que especificar el registro

;Postcondiciones: El regisgtro designado tendra algun valor entre 0 y 3

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023          
IN_SUB:
        MOV.B #02h,  &0xA22
        
        CALL #DELAY_3S
        
        AND.B #11111101b, &0xA22
        
        PUSH.W R4
        
        MOV.B &P1IN, R4
        
        RRA.W R4
        
        AND.B #00000011b, R5
        
        CMP.B #0, R5
        JEQ IN_SUB_R0
        
        CMP.B #1, R5
        JEQ IN_SUB_R1
        
        CMP.B #2, R5
        JEQ IN_SUB_R2
        
        CMP.B #3, R5
        JEQ IN_SUB_R3
        
IN_SUB_R0:
        MOV.B R4, R10
        JMP IN_SUB_END
        
IN_SUB_R1:
        MOV.B R4, R11
        JMP IN_SUB_END
        
IN_SUB_R2:
        MOV.B R4, R12
        JMP IN_SUB_END
        
IN_SUB_R3:
        MOV.B R4, R13
        JMP IN_SUB_END

IN_SUB_END:
        POP R4
        RET
        
        

      
      
        
        

;Objetivo: Hacer output al display del MSP 

;Precondiciones: IR (R5) tiene que determinar a que direccion se le hara el output
;                y que registro sera el source del contendio que se mostrara.
;               

;Postcondiciones: El display mostrara el contenido del registro ss en la direccion aa
;                aa 00 = HexDisplay
;                   01 = Bateria
;                   10= Timer

;Autor: John Trinidad

OUT_SUB:
      
      PUSH.B R5          ;COPY INSTRUCCTION
      AND.B #00000011B,R5
      CMP.B #0,R5
      JEQ HexDisplay
      CMP.B #1,R5
      JEQ BateriaCall
      JNE Timer
      
BateriaCall:
      Call #Bateria 
      ret
      
;Objetivo: Simular un Timer en el display del MSP

;Precondiciones: (IR) R5 tiene que tener una instruccion valida correspondiente a Timer

;Postcondiciones: Se debe ejecutar un timer desde el valor determinado por el registro hasta 0

;Autor: John Trinidad
Timer:
      MOV.W #2,&LCDCMEMCTL
      PUSH.W R4
      PUSH.W R6
      PUSH.W R7
      PUSH.W R9
      MOV.B #0,R4
      MOV.B #0,R6
      MOV.B #0,R9
      bic.b   #0xff,&0x0A29
      bic.b   #0xff,&0x0A2a
      bic.b   #0xff,&0x0a25
      bic.b   #0xff,&0x0A26
      bic.b   #0xff,&0x0a23
      Bic.b   #0xff,&0x0A24
      bis     #0000000000010000b,&TA0CTL
      POP.B R5    ;Restore Instrucction to full version
      Push.B R5   ;keep another copy to mask R5
      AND #00001100B,R5
      RRA R5
      RRA R5
      CMP.B #0,R5
      JEQ TimerR0
      CMP.B #1,R5
      JEQ TimerR1
      CMP.B #2,R5
      JEQ TimerR2
      CMP.B #3,R5
      JEQ TimerR3
      
      
TimerR0:
      PUSH.B R8
      MOV.B R10,R8
      Call #TimerCIEN
      RET

TimerR1:
      PUSH.B R8
      MOV.B R11,R8
      Call #TimerCIEN
      RET
TimerR2:
      PUSH.B R8
      MOV.B R12,R8
      Call #TimerCIEN
      RET
TimerR3:
      PUSH.B R8
      MOV.B R13,R8
      Call #TimerCIEN
      RET
      
TimerCIEN:
       cmp.B #100,R8
       JLO TimerDIEZ
       Sub.w #100,R8
       inc.b R4
       JMP TimerCIEN
TimerDIEZ:
       cmp #10,R8
       JLO TimerUNO
       Sub.w #10,R8
       inc.b R6
       JMP TimerDIEZ
TimerUNO:
       cmp #1,R8
       JLO SaveTimerValues
       Sub.w #1,R8
       inc.b R7
       JMP TimerUNO

SaveTimerValues:
      Push.w R7
      Push.w R6
      Push.w R4
      
;Objetivo: Escribir en el display el valor inicial del timer en el lcd

;Precondiciones: Los registros deben contener la "traduccion" del registro de origen a tipo decimal

;Postcondiciones: Se escribe el valor completo en la pantalla del MSP

;Autor: John Trinidad
SetTimerValuesToLcd:
      POP.b R8
      MOV.W pos1(R9),R15
      cmp #0,R8
      jEQ setLCDZero
      cmp #1,R8
      JEQ setLCDOne
      cmp #2,R8
      JEQ setLCDTwo
      cmp #3,R8
      JEQ setLCDThree
      cmp #4,R8
      JEQ setLCDFour
      cmp #5,R8
      JEQ setLCDFive
      cmp #6,R8
      JEQ setLCDSix
      cmp #7,R8
      JEQ setLCDSeven
      cmp #8,R8
      JEQ setLCDEight
      JMP setLCDNine
      
setLCDZero:
        mov.b #11111100b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDOne:
        mov.b #01010000b,1(R15)
        add #2,R9
        JMP LCDCheck
setLCDTwo:
        mov.b #11011011b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDThree:
        mov.b #11110011b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDFour:
        mov.b #01100111b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDFive:
        mov.b #10110111b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDSix:
        mov.b #10111111b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDSeven:
        mov.b #11100000b,0(R15)
        add #2,R9
        JMP LCDCheck
setLCDEight:
        mov.b #11111111b,0(R15)
        add  #2,R9
        JMP  LCDCheck
setLCDNine:
        mov.b #11100111b,0(R15)
        add #2,R9
       
LCDCheck:
        cmp #6,R9
        JNZ SetTimerValuesToLcd
       
LCDEND:
        bis.b  #1,&0x0a26
        cmp.b #0, runindebugger
        JEQ countdown
        
noCountdown:
      POP.B R4
      CALL #LOOP
      RET
        
;Objetivo: Simular un count down en el display

;Precondiciones: indebugger debe contener 0 

;Postcondiciones: Se debe ejecutar un timer desde el valor determinado por el registro hasta 0
;utilizando un delay para simular conteo regresivo

;Autor: John Trinidad       
countdown:
    
    bis.b  #1,&0x0a26
    mov #8, R10
outer_loop:
    mov #4000, R11
inner_loop:
    dec R11
    jnz inner_loop
    dec R10
    jnz outer_loop

    ; Update the countdown
    dec R7            ; Decrease the tenths of seconds
    cmp #9, R7        ; Check if R7 > 9 after decrement (underflowed)
    jlo check_end

    ; Reset the tenths of seconds and decrease the ones of seconds
    mov #9, R7
    dec R6
    cmp #9, R6        ; Check if R6 > 9 after decrement (underflowed)
    jlo check_end

    ; Reset the ones of seconds and decrease the tens of seconds
    mov #9, R6        ; Reset R6 to 9
    dec R5

check_end:
    ; Check if the countdown has reached 0
    cmp #0, R5
    jne update_display
    cmp #0, R6
    jne update_display
    cmp #0, R7
    jne update_display
    jmp end_countdown
;Objetivo: Cambiar display a valor deseado luego de pasado el delay determinado

;Precondiciones: Debemos estar en indebugger=0 para que se ejecute y se actualice el display

;Postcondiciones: Se debe ejecutar un timer desde el valor determinado por el registro hasta 0
;                 terminando en 00.0 

;Autor: John Trinidad
update_display:
    
    CALL #ReDrawR7
    CALL #ReDrawR6
    CALL #ReDrawR5
    jmp countdown
    

ReDrawR7:
    CMP.B #0,R7
    JEQ Draw0tR7
    CMP.B #1,R7
    JEQ Draw1tR7
    CMP.B #2,R7
    JEQ Draw2tR7
    CMP.B #3,R7
    JEQ Draw3tR7
    CMP.B #4,R7
    JEQ Draw4tR7
    CMP.B #5,R7
    JEQ Draw5tR7
    CMP.B #6,R7
    JEQ Draw6tR7
    CMP.B #7,R7
    JEQ Draw7tR7
    CMP.B #8,R7
    JEQ Draw8tR7
    CMP.B #9,R7
    JEQ Draw9tR7
    
Draw0tR7:
     mov.b #0xFC,&0xA23
     mov.b #0x28,&0xA24
     RET
Draw1tR7:
     mov.b #0x60,&0xA23
     mov.b #0x20,&0xA24
     RET

Draw2tR7:
     mov.b #0xDB,&0xA23
     mov.b #0x00,&0xA24
     RET
Draw3tR7:
     mov.b #0xF3,&0xA23
     mov.b #0x00,&0xA24
     RET

Draw4tR7: 
     mov.b #0x67,&0xA23
     mov.b #0x00,&0xA24
     RET

Draw5tR7:
     mov.b #0xB7,&0xA23
     mov.b #0x00,&0xA24
     RET

Draw6tR7:
     mov.b #0xBF,&0xA23
     mov.b #0x00,&0xA24
     RET

Draw7tR7:
     mov.b #0x80,&0xA23
     mov.b #0x28,&0xA24
     RET

Draw8tR7:
     mov.b #0xFF,&0xA23
     mov.b #0x00,&0xA24
     RET

Draw9tR7:
     mov.b #0xF7,&0xA23
     mov.b #0x00,&0xA24
     RET

ReDrawR6:
    CMP.B #0,R6
    JEQ Draw0tR6
    CMP.B #1,R6
    JEQ Draw1tR6
    CMP.B #2,R6
    JEQ Draw2tR6
    CMP.B #3,R6
    JEQ Draw3tR6
    CMP.B #4,R6
    JEQ Draw4tR6
    CMP.B #5,R6
    JEQ Draw5tR6
    CMP.B #6,R6
    JEQ Draw6tR6
    CMP.B #7,R6
    JEQ Draw7tR6
    CMP.B #8,R6
    JEQ Draw8tR6
    CMP.B #9,R6
    JEQ Draw9tR6
    
Draw0tR6:
     mov.b #0xFC,&0XA25
     mov.b #0x28,&0XA26
     RET
Draw1tR6:
     mov.b #0x60,&0XA25
     mov.b #0x20,&0XA26
     RET

Draw2tR6:
     mov.b #0xDB,&0XA25
     mov.b #0x00,&0XA26
     RET
Draw3tR6:
     mov.b #0xF3,&0XA25
     mov.b #0x00,&0XA26
     RET

Draw4tR6: 
     mov.b #0x67,&0XA25
     mov.b #0x00,&0XA26
     RET

Draw5tR6:
     mov.b #0xB7,&0XA25
     mov.b #0x00,&0XA26
     RET

Draw6tR6:
     mov.b #0xBF,&0XA25
     mov.b #0x00,&0XA26
     RET

Draw7tR6:
     mov.b #0x80,&0XA25
     mov.b #0x28,&0XA26
     RET

Draw8tR6:
     mov.b #0xFF,&0XA25
     mov.b #0x00,&0XA26
     RET

Draw9tR6:
     mov.b #0xF7,&0XA25
     mov.b #0x00,&0XA26
     RET
ReDrawR5:
    CMP.B #0,R5
    JEQ Draw0tR5
    CMP.B #1,R5
    JEQ Draw1tR5
    CMP.B #2,R5
    JEQ Draw2tR5
    CMP.B #3,R5
    JEQ Draw3tR5
    CMP.B #4,R5
    JEQ Draw4tR5
    CMP.B #5,R5
    JEQ Draw5tR5
    CMP.B #6,R5
    JEQ Draw6tR5
    CMP.B #7,R5
    JEQ Draw7tR5
    CMP.B #8,R5
    JEQ Draw8tR5
    CMP.B #9,R5
    JEQ Draw9tR5
    
Draw0tR5:
     mov.b #0xFC,&0XA29
     mov.b #0x28,&0XA2A
     RET
Draw1tR5:
     mov.b #0x60,&0XA29
     mov.b #0x20,&0XA2A
     RET

Draw2tR5:
     mov.b #0xDB,&0XA29
     mov.b #0x00,&0XA2A
     RET
Draw3tR5:
     mov.b #0xF3,&0XA29
     mov.b #0x00,&0XA2A
     RET

Draw4tR5: 
     mov.b #0x67,&0XA29
     mov.b #0x00,&0XA2A
     RET

Draw5tR5:
     mov.b #0xB7,&0XA29
     mov.b #0x00,&0XA2A
     RET

Draw6tR5:
     mov.b #0xBF,&0XA29
     mov.b #0x00,&0XA2A
     RET

Draw7tR5:
     mov.b #0x80,&0XA29
     mov.b #0x28,&0XA2A
     RET

Draw8tR5:
     mov.b #0xFF,&0XA29
     mov.b #0x00,&0XA2A
     RET

Draw9tR5:
     mov.b #0xF7,&0XA29
     mov.b #0x00,&0XA2A
     RET
end_countdown:
     Call #Draw0tR7
     CALL #LOOP
     RET
; Countdown reached 0



      
;Objetivo: Hacer output al display del MSP direccion 00=hex display 

;Precondiciones: IR (R5) debe determinar 00 como output 
;                
;               

;Postcondiciones: El display hexadecimal mostrsra el valor del registro deseado
;                

;Autor: John Trinidad
HexDisplay:
      POP.B R5    ;Restore Instrucction to full version
      Push.B R5   ;keep another copy to mask R5
      AND #00001100B,R5
      RRA R5
      RRA R5
      CMP.B #0,R5
      JEQ HexDisplayR0
      CMP.B #1,R5
      JEQ HexDisplayR1
      CMP.B #2,R5
      JEQ HexDisplayR2
      CMP.B #3,R5
      JEQ HexDisplayR3


HexDisplayR0:  

        PUSH.B R5
        PUSH.B R6
        Mov.B #27,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        RET
        
        
HexDisplayR1:
        
        cmp #0,R11
        JEQ DisplayZERO
        cmp #1,R11
        JEQ DisplayOne
        cmp #2,R11
        JEQ DisplayTWO
        cmp #3,R11
        JEQ DisplayThree
        cmp #4,R11
        JEQ DisplayFour
        cmp #5,R11
        JEQ DisplayFive
        cmp #6,R11
        JEQ DisplaySix
        cmp #7,R11
        JEQ DisplaySeven
        cmp #8,R11
        JEQ DisplayEight
        cmp #9,R11
        JEQ DisplayNine
        cmp #10,R11
        JEQ DisplayTen 
        cmp #11,R11
        JEQ DisplayElleven
        cmp #12,R11
        JEQ DisplayTwelve
        cmp #13,R11
        JEQ DisplayThirdteen
        CMP #14,R11
        JEQ DisplayFourteen
        CMP #15,R11
        JEQ DisplayFithteen
        RET

HexDisplayR2:
        
        cmp #0,R12
        JEQ DisplayZERO
        cmp #1,R12
        JEQ DisplayOne
        cmp #2,R12
        JEQ DisplayTWO
        cmp #3,R12
        JEQ DisplayThree
        cmp #4,R12
        JEQ DisplayFour
        cmp #5,R12
        JEQ DisplayFive
        cmp #6,R12
        JEQ DisplaySix
        cmp #7,R12
        JEQ DisplaySeven
        cmp #8,R12
        JEQ DisplayEight
        cmp #9,R12
        JEQ DisplayNine
        cmp #10,R12
        JEQ DisplayTen 
        cmp #11,R12
        JEQ DisplayElleven
        cmp #12,R12
        JEQ DisplayTwelve
        cmp #13,R12
        JEQ DisplayThirdteen
        CMP #14,R12
        JEQ DisplayFourteen
        CMP #15,R12
        JEQ DisplayFithteen
        RET

HexDisplayR3:
        
        cmp #0,R13
        JEQ DisplayZERO
        cmp #1,R13
        JEQ DisplayOne
        cmp #2,R13
        JEQ DisplayTWO
        cmp #3,R13
        JEQ DisplayThree
        cmp #4,R13
        JEQ DisplayFour
        cmp #5,R13
        JEQ DisplayFive
        cmp #6,R13
        JEQ DisplaySix
        cmp #7,R13
        JEQ DisplaySeven
        cmp #8,R13
        JEQ DisplayEight
        cmp #9,R13
        JEQ DisplayNine
        cmp #10,R13
        JEQ DisplayTen 
        cmp #11,R13
        JEQ DisplayElleven
        cmp #12,R13
        JEQ DisplayTwelve
        cmp #13,R13
        JEQ DisplayThirdteen
        CMP #14,R13
        JEQ DisplayFourteen
        CMP #15,R13
        JEQ DisplayFithteen
        RET
        
DisplayZERO:

        PUSH.B R5
        PUSH.B R6
        Mov.B #27,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayOne:

        PUSH.B R5
        PUSH.B R6
        Mov.B #28,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET

DisplayTWO:

        PUSH.B R5
        PUSH.B R6
        Mov.B #29,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET

DisplayThree:

        PUSH.B R5
        PUSH.B R6
        Mov.B #30,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET

DisplayFour:

       PUSH.B R5
       PUSH.B R6
        Mov.B #31,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET

DisplayFive:

       PUSH.B R5
       PUSH.B R6
        Mov.B #32,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET

DisplaySix:

       PUSH.B R5
       PUSH.B R6
        Mov.B #33,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplaySeven:

       PUSH.B R5
       PUSH.B R6
        Mov.B #34,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET

DisplayEight:

       PUSH.B R5
       PUSH.B R6
        Mov.B #35,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayNine:

       PUSH.B R5
       PUSH.B R6
        Mov.B #36,R5
        MOV.B #7,R6
        MOV.B highByte(R5),0x0A20(R6)
        MOV.B lowByte(R5), 0x0A20+1(R6)
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayTen:

       PUSH.B R5
       PUSH.B R6
       PUSH.B R7
       PUSH.B R8
        MOV #0,R5
        MOV #4,R7
        CALL #DisplayTenLoop
        RET
        
DisplayTenLoop:

        Mov.B alphanumeric(R7),R8
        MOV.B TEN(R5),R6
        MOV.B highByte(R6),0x0A20(R8)
        MOV.B lowByte(R6), 0x0A20+1(R8)
        INC.B R5
        INC.B R7
        CMP.B #3,R5
        JNE DisplayTenLoop
        POP R8
        POP R7
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayElleven:

       PUSH.B R5
       PUSH.B R6
       PUSH.B R7
       PUSH.B R8
        MOV #0,R5
        MOV #4,R7
        CALL #DisplayEllevenLoop
        RET
        
DisplayEllevenLoop:

        Mov.B alphanumeric(R7),R8
        MOV.B ELLEVEN(R5),R6
        MOV.B highByte(R6),0x0A20(R8)
        MOV.B lowByte(R6), 0x0A20+1(R8)
        INC.B R5
        INC.B R7
        CMP.B #3,R5
        JNE DisplayEllevenLoop
        POP R8
        POP R7
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayTwelve:

        PUSH.B R5
        PUSH.B R6
        PUSH.B R7
        PUSH.B R8
        MOV #0,R5
        MOV #4,R7
        
        CALL #DisplayTwelveLoop
        RET
        
DisplayTwelveLoop:

        Mov.B alphanumeric(R7),R8
        MOV.B TWELVE(R5),R6
        MOV.B highByte(R6),0x0A20(R8)
        MOV.B lowByte(R6), 0x0A20+1(R8)
        INC.B R5
        INC.B R7
        CMP.B #3,R5
        JNE DisplayTwelveLoop
        POP R8
        POP R7
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayThirdteen:

       PUSH.B R5
       PUSH.B R6
       PUSH.B R7
       PUSH.B R8
        MOV #0,R5
        MOV #4,R7
        CALL #DisplayThirdteenLoop
        RET
        
DisplayThirdteenLoop:

        Mov.B alphanumeric(R7),R8
        MOV.B THRIDTEEN(R5),R6
        MOV.B highByte(R6),0x0A20(R8)
        MOV.B lowByte(R6), 0x0A20+1(R8)
        INC.B R5
        INC.B R7
        CMP.B #3,R5
        JNE DisplayThirdteenLoop
        POP R8
        POP R7
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayFourteen:

       PUSH.B R5
       PUSH.B R6
       PUSH.B R7
       PUSH.B R8
       MOV #0,R5
       MOV #4,R7
       CALL #DisplayFourteenLoop
       RET
        
DisplayFourteenLoop:

        Mov.B alphanumeric(R7),R8
        MOV.B FOURTEEN(R5),R6
        MOV.B highByte(R6),0x0A20(R8)
        MOV.B lowByte(R6), 0x0A20+1(R8)
        INC.B R5
        INC.B R7
        CMP.B #3,R5
        JNE DisplayFourteenLoop 
        POP R8
        POP R7
        POP R6
        POP R5
        CALL #LOOP
        RET
        
DisplayFithteen:

       PUSH.B R5
       PUSH.B R6
       PUSH.B R7
       PUSH.B R8
       MOV #0,R5
       MOV #4,R7
       CALL #DisplayFithteenLoop
       RET
        
DisplayFithteenLoop:

        Mov.B alphanumeric(R7),R8
        MOV.B FITHTEEN(R5),R6
        MOV.B highByte(R6),0x0A20(R8)
        MOV.B lowByte(R6), 0x0A20+1(R8)
        INC.B R5
        INC.B R7
        CMP.B #3,R5
        JNE DisplayFithteenLoop 
        POP.B R8
        POP.B R7
        POP.B R6
        POP.B R5
        CALL #LOOP
        RET
        
        

;Objetivo: Hacer output al display del MSP direccion 01=Bateria

;Precondiciones: IR (R5) debe determinar 01 como output 
;                
;               

;Postcondiciones: El display debe mostrar la Bateria con sus secciones correspondiente
;                 mostrsra el valor del registro deseado
;                

;Autor: John Trinidad
Bateria:

      POP.B R5    ;Restore Instrucction to full version
      Push.B R5   ;keep another copy to mask R5
      AND #00001100B,R5
      RRA R5
      RRA R5
      CMP.B #1,R5
      JEQ BateriaDisplayR1
      CMP.B #2,R5
      JEQ BateriaDisplayR2
      CMP.B #3,R5
      JEQ BateriaDisplayR3
      RET

BateriaDisplayR1:
      
      MOV R11,R8
      CALL #DisplayBattR8
      RET
      
BateriaDisplayR2:
      
      MOV R12,R8
      CALL #DisplayBattR8
      RET
      
BateriaDisplayR3:
      PUSH.B R8
      MOV R13,R8
      CALL #DisplayBattR8
      RET

DisplayBattR8:
      
      CMP.B #128,R8
      JEQ B1
      CMP.B #64,R8
      JEQ B2
      CMP.B #32,R8
      JEQ B3
      CMP.B #16,R8
      JEQ B4
      CMP.B #8,R8
      JEQ B5
      CMP.B #4,R8
      JEQ B6
      CMP.B #2,R8
      JEQ Bracket
      CMP.B #1,R8
      JEQ BATT
      RET
           
      
B1:
      bis.b #00100000b,&0xa31
      sub #64,R8
      Call #DisplayBattR8
      RET
B2:
      bis.b #00100000b,&0XA2D
      sub #32,R8
      Call #DisplayBattR8
      RET
B3:
      bis.b #01000000b,&0xa31
      sub.B #16,R8
      Call #DisplayBattR8
      RET
B4:
      bis.b #01000000b,&0XA2D
      sub #8,R8
      Call #DisplayBattR8
      RET      
B5:
      bis.b #10000000b,&0xa31
      sub #4,R8
      Call #DisplayBattR8
      RET   
      
B6:
      bis.b #10000000b,&0XA2D
      sub #2,R8
      Call #DisplayBattR8
      RET 

Bracket:
      bis.b #00010000B,&0XA31
      SUB #1,R8
      CALL #DisplayBattR8
      RET
BATT:
      bis.b #00010000B,&0XA2D
      CALL #DisplayBattFinish
      RET
      
DisplayBattFinish:
      pop.b R8
      CALL #LOOP
      RET
        
;Objetivo: Cambiar el contenido del PC si R3 tiene un 0

;Precondiciones: IR (R5) tiene que especificar el valor ira en el PC (R4).
;                R3 (R13) tiene que tener contenido un 0

;Postcondiciones: PC (R4) tendra el contenido que se le indico en el IR (R5).

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023    
JR30_SUB:
        CMP.B #0,R13
        JNE JR30_SUB_END
        AND.B #00001111b, R5
        MOV.B R5, R4       
JR30_SUB_END:
        CALL #LOOP
        RET
        
        
;Objetivo: Mostrar los primeros 6 caracteres alfanumericos a partir de un array

;Precondiciones: Poner una direccion en R4

;Postcondiciones: El LCD mostara el contenido correspondiente hasta que se cambie 

;Autor: Edimar Valentin Kery

;Fecha: 19/abr/2023              
R4toLCD:
       PUSH.W R5                       ;We're gonna need these three registers to do our iteration business. We're backing up their contents
       PUSH.W R6                       ;to the stack.
       PUSH.W R7                       

        MOV.B #0, R5                    ;We're gonna use R5 to iterate the alphanumerics on the LCD
R4toLCDLoop:
        MOV.B  @R4+, R6                 ;This is is gonna work as our index for the content on R4. We move to it to R6 and increment it by one

        MOV.B alphanumeric(R5), R7      ;We copy the position of the alphanumeric to the LCD


        MOV.B highByte(R6), 0x0A20(R7)  ;The corresponding high byte with the corresponding alphanumeric
      
        MOV.B lowByte(R6), 0x0A20+1(R7) ;The corresponding low byte with the corresponding alphanumeric
      
        INC.B R5                        ;Increment R5 to go to the next alphanumeric
      
        CMP #6, R5                      ;If R5 reached 6, that means there's no more space on the LCD
      
        JNE R4toLCDLoop                 ;If there still space, repeat the subroutine with the new values

        POP.W R7                        ;We return the used registers to the their original state. 
        POP.W R6
        POP.W R5
        
        RET                             ;We return to wherever we were called 



;Objetivo: Interrupt Service Routine que maneja las acciones a tomar de s1 o s2

;Precondiciones: Las interrupciones en P1.1 & P1.2 y el MSP430 en general tienen que estar habilitadas.
;                El programa tiene que estar en el estado de 'CPURUM', 'S2TOGO' o mostrando los nombres de los integrantes.

;Postcondiciones: Mostrar el nombre del siguiente integrante, mostrar 'S2TOGO' o empezar el programa.

;Autor: Edimar Valentin Kery

;Fecha: 19/abr/2023  
PORT1_ISR:
        
       PUSH.W R4
        
        NOP
        BIC.B   #6, &P1IFG        
        NOP
        
        CALL    #DELAY
        
        MOV.B   &P1IN, R4               
        
        AND.B   #00000110B, R4 
        
        cmp.b   #4, R4           
        jeq     S1_PRESSED_ISR  
       
        cmp.b   #2, R4                   
        jeq     S2_PRESSED_ISR
        
        JMP END_PORT1_ISR
        
        
S1_PRESSED_ISR:

        CMP.W #0, STATE
        JEQ S1_PRESSED_ISR_S2TOGO
        JMP END_PORT1_ISR
        
S1_PRESSED_ISR_S2TOGO:    
        PUSH.W R4
        MOV.W #S2TOGO, R4
        CALL #R4toLCD
        POP.W R4
        INC.W STATE
        JMP END_PORT1_ISR
   
S2_PRESSED_ISR:
        CMP.W #0, STATE
        JEQ SHOW_NAME_ISR
        
        CMP.W #1, STATE
        JEQ START_PROGRAM_ISR
        
        JMP END_PORT1_ISR
        
START_PROGRAM_ISR:
        INC.W STATE
        JMP END_PORT1_ISR
          
SHOW_NAME_ISR:
        CMP.W #0, S2COUNT
        JEQ DISPLAY_EDIMAR_ISR
        
        CMP.W #1, S2COUNT
        JEQ DISPLAY_JOHN_ISR
        
        CMP.W #2, S2COUNT
        JEQ DISPLAY_NORELY_ISR
        
        CMP.W #3, S2COUNT
        JEQ DISPLAY_BRYANT_ISR
        
        JMP END_PORT1_ISR
        
DISPLAY_EDIMAR_ISR:
        PUSH.W R4
        MOV.W #EDIMAR, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_JOHN_ISR:
        PUSH.W R4
        MOV.W #JOHN, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_NORELY_ISR:
        PUSH.W R4
        MOV.W #NORELY, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_BRYANT_ISR:
        PUSH.W R4
        MOV.W #BRYANT, R4
        CALL #R4toLCD
        POP.W R4
        MOV.W #0, S2COUNT
        JMP END_PORT1_ISR
        
END_PORT1_ISR:
        POP.W R4
        reti
        
   
;Objetivo: Crear un delay para no actuar en el sonido de los botones s1 y s2

;Precondiciones: Ninguna

;Postcondiciones: La subrutina no genera cambios 

;Autor: Edimar Valentin Kery

;Fecha: 20/abr/2023

DELAY:
        PUSH.W R4
        MOV #1000, R4
NEXT:   
        DEC.W R4
        JNZ NEXT
        POP.W R4
        RET
        

;Objetivo: Mantener al MSP430 "ocupado" por 3 segundos

;Precondiciones: Ninguna

;Postcondiciones: La subrutina no genera cambios

;Autor: Edimar Valentin Kery

;Fecha: 21/abr/2023            
DELAY_3S:
           ; Assuming a 1 MHz clock
    PUSH.B R14
    PUSH.B R15
    PUSH.B R8
    ; Initialize loop counters
    mov #500, R14
    mov #1500, R15

delay_outer_loop:
    ; Inner loop (3,000 cycles per iteration)
    mov R15, R8
delay_inner_loop:
    dec R8
    jnz delay_inner_loop

    ; Decrement outer loop counter and check if it reached zero
    dec R14
    jnz delay_outer_loop
    POP.B R8
    POP.B R15
    POP.B R14
    RET
      
END      
   