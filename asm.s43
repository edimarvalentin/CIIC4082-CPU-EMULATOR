#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.

        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).
        
        
        ORG     0x1C00                  ; moving to set some variables

; Letters and Digits Mapping for LCD
; Letter/Digit    A     B     C     D     E     F     G     H     I     J     K     L     M      N    O     P    Q    R      S    T     U       V      W    X     Y   Z     Empty  0      1     2     3     4     5     6    7     8     9
; Indice          0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15   16   17    18    19    20     21     22    23   24   25     26    27    28    29    30    31    32    33    34    35    36
highByte db     0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8F, 0xBD, 0x6F, 0x90, 0x98, 0x00, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7
         align 1
lowByte  db     0x00, 0x50, 0x00, 0x50, 0x00, 0X00, 0x00, 0x00, 0x50, 0x50, 0x72, 0x00, 0XA0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0X28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00    
         align 1

;LCD Alphanumerics 1 to 6
alphanumeric db 9, 5, 3, 18, 14, 7
             align 1

;CPURUM array
CPURUM  db      2, 15, 20, 17, 20, 12
        align   1
        
;ST2GO array
S2TOGO   db      18, 29, 19, 14, 6, 14
        align   1
        
;Names
EDIMAR db       4, 3, 8, 12, 0, 17
       align    1
       
JOHN   db       9, 14, 7, 13, 26, 26
       align    1
       
NORELY db       13, 14, 17, 4, 11, 24
       align    1
       
BRYAN  db       1, 17, 24, 0, 13, 26
       align    1
       
;To know and compare what state is the program in       
STATE    dw    0

S2COUNT  dw    0
        
        ORG     0FFFEh                  ; back to normal
        
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

SetupP1:
        BIS.B   #11111001B, &P1DIR      ; Port 1.1 & Port 1.2 for button input, all other as output
        MOV.B   #00000110B, &P1OUT      ; P1.1 Resistor enabled as pullup
        MOV.B   #00000110B, &P1REN      ; resistor. Push is read as 0 and else 1
        MOV.B   #00000110B, &P1IES      ; Int generated on high to low transition
        MOV.B   #00000110B, &P1IE       ; Enable interrupt at P1.1 & P1.2
        
        ;Initialize LCD segments 0 - 21; 26 - 43
	MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2
        
UnlockGPIO:
        BIC.W   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings
        NOP

        ;Intialize LCD_C
        MOV.W   #0x041e,&LCDCCTL0
        
        ;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL
        
        MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

        MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        BIS.W   #1,&LCDCCTL0         ;Turn on LCD

;Display CPURUM
displayCPURUM:
        PUSH.W R4                       ;Save the content of R4 to the stack to back it up
        MOV.W #CPURUM, R4               ;Move the address of CPURUM to R4 so we can iterate it to the LCD
        CALL #R4toLCD                   ;Display the content of R4 to the LCD
        POP.W R4                        ;Return R4 to the original state 

enablePort1_ISR:
        bic.b   #00000010b, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
        NOP                             ;NOP before setting GIE required by
                                        ;the architecture
        BIS.W   #GIE,SR 	        ;Interrupts enabled (same as eint)
                                        ;so that the micro reacts to 
                                        ;interrupts
        NOP                             ;Wait after setting interrupt bit

StartLoop:
        CMP #2, STATE
        JLO StartLoop
     
        JMP $
        
R4toLCD:
        PUSH.W R5                       ;We're gonna need these three registers to do our iteration business. We're backing up their contents
        PUSH.W R6                       ;to the stack.
        PUSH.W R7                       

        MOV.B #0, R5                    ;We're gonna use R5 to iterate the alphanumerics on the LCD
R4toLCDLoop:
        MOV.B  @R4+, R6                 ;This is is gonna work as our index for the content on R4. We move to it to R6 and increment it by one

        MOV.B alphanumeric(R5), R7      ;We copy the position of the alphanumeric to the LCD


        MOV.B highByte(R6), 0x0A20(R7)  ;The corresponding high byte with the corresponding alphanumeric
      
        MOV.B lowByte(R6), 0x0A20+1(R7) ;The corresponding low byte with the corresponding alphanumeric
      
        INC.B R5                        ;Increment R5 to go to the next alphanumeric
      
        CMP #6, R5                      ;If R5 reached 6, that means there's no more space on the LCD
      
        JNE R4toLCDLoop                 ;If there still psace, repeat the subroutine with the new values

        POP.W R7                        ;We return the used registers to the their original state. 
        POP.W R6
        POP.W R5
        
        RET                             ;We return to wherever we were called 


PORT1_ISR:
        
        PUSH.W R4
        
        NOP
        BIC.B   #6, &P1IFG        
        NOP
        
        CALL    #DELAY
        
        MOV.B   &P1IN, R4               
        
        AND.B   #00000110B, R4 
        
        cmp.b   #4, R4           
        jeq     S1_PRESSED_ISR  
       
        cmp.b   #2, R4                   
        jeq     S2_PRESSED_ISR
        
        JMP END_PORT1_ISR
        
        
S1_PRESSED_ISR:
        ;ST2GO
        PUSH.W R4
        MOV.W #S2TOGO, R4
        CALL #R4toLCD
        POP.W R4
        INC.W STATE
        JMP END_PORT1_ISR
       
;Will show names or start the program
S2_PRESSED_ISR:
        CMP.W #0, STATE
        JEQ SHOW_NAME_ISR
        
        CMP.W #1, STATE
        JEQ START_PROGRAM_ISR
        
        JMP END_PORT1_ISR
        
START_PROGRAM_ISR:
        INC.W STATE
        JMP END_PORT1_ISR
          
SHOW_NAME_ISR:
        CMP.W #0, S2COUNT
        JEQ DISPLAY_EDIMAR_ISR
        
        CMP.W #1, S2COUNT
        JEQ DISPLAY_JOHN_ISR
        
        JMP END_PORT1_ISR
        
DISPLAY_EDIMAR_ISR:
        PUSH.W R4
        MOV.W #EDIMAR, R4
        CALL #R4toLCD
        POP.W R4
        INC.W S2COUNT
        JMP END_PORT1_ISR
        
DISPLAY_JOHN_ISR:
        PUSH.W R4
        MOV.W #JOHN, R4
        CALL #R4toLCD
        POP.W R4
        DEC.W S2COUNT
        JMP END_PORT1_ISR
        
END_PORT1_ISR:
        POP.W R4
        reti
        
        
DELAY:
        PUSH.W R4
        MOV #1000, R4
NEXT:   
        DEC.W R4
        JNZ NEXT
        POP.W R4
        RET
                                              
END      
   


        
 
    